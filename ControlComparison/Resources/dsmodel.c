#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model ControlComparison.Optimization.SimpleExample.Model02
 Dymola Version 2021 (64-bit), 2020-04-17 translated this at Fri May 28 16:17:18 2021

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    3
#define NX2_   0
#define NU_    0
#define NY_    1
#define NW_    5
#define NP_    2
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -593041864
#define NHash2_ -1855605007
#define NHash3_ 1654603759
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    4
#define SizePre_ 0
#define SizeEq_ 0
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 2
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="ControlComparison.Optimization.SimpleExample.Model02";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/programdata/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[7]={1 , 3 , 1 , 2 , 3 , 0 , 0};
static int QJacobianGrp0[4]={2, 1, 1, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[2]={
{0, QJacobianGrp0},{0,0}};
DYMOLA_STATIC double QJacobianCD_[4]={0  , 44 , 55 , 66};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,3) = false;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,0) = DYNX(DP_,0);
DYNX(W_,1) = DYNX(DP_,1);
InitialSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(Y_,0) = 0;
DYNX(F_,0) = 0;
DYNX(X_,0) = 3;
DYNX(X_,1) = 0;
DYNX(X_,2) = 0;
DYNX(W_,4) = DYNTime;
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection
DYNX(Y_,0) = DYNX(X_,2);

DynamicsSection
DYNX(F_,0) = DYNX(X_,1);
DYNX(DYNhelp,0) = cos(DYNX(W_,1)*DYNTime);
DYNX(F_,1) = DYNX(W_,0)*(3+DYNX(DYNhelp,0)-DYNX(X_,0));
DYNX(DYNhelp,1) = sin(2*DYNTime);
DYNX(W_,2) = 3+DYNTime*DYNX(DYNhelp,1);
DYNX(F_,2) = sqr(DYNX(W_,2)-DYNX(X_,0));

AcceptedSection1

AcceptedSection2

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("a", "", 0, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("b", "", 1, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("model01_part.a", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("model01_part.b", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareState("model01_part.x1", "", 0, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("model01_part.der(x1)", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("model01_part.x2", "", 1, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("model01_part.der(x2)", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("model01_part.y", "", "model01_part.x1", 1, 1, 0, 0)
DeclareVariable("integratedSquaredDeviation.u1", "Connector of Real input signal 1",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("integratedSquaredDeviation.u2", "Connector of Real input signal 2",\
 "model01_part.x1", 1, 1, 0, 0)
DeclareAlias2("integratedSquaredDeviation.y", "Connector of Real output signal",\
 "integratedSquaredDeviation.y1", 1, 1, 2, 0)
DeclareVariable("integratedSquaredDeviation.normalizeToInterval", \
"If true, then y will be scaled to length of integration interval [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareState("integratedSquaredDeviation.y1", "", 2, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("integratedSquaredDeviation.der(y1)", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("integratedSquaredDeviation.startTime", "[s]", 0.0, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("realExpression.y", "Value of Real output", "integratedSquaredDeviation.u1", 1,\
 5, 2, 0)
DeclareOutput("y", "", 0, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
EndDataBlock
